package scriptism;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTree;
import org.apache.commons.lang3.reflect.MethodUtils;
import scriptism.grammar.ScriptismLexer;
import scriptism.grammar.ScriptismParser;

import java.io.FileInputStream;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;

public class Main {

    public static void main(String... args) throws IOException,
            NoSuchMethodException,
            IllegalAccessException,
            InvocationTargetException, ClassNotFoundException {

        Options options = CommandLineOptions.parse(args);
        if (options.getShouldExit()) {
            System.exit(options.getExitStatus());
        }

        // The process of compiling Scriptism to an executable format is
        // basically a two step process. First, lex and parse the input file.
        // Second, transform it to byte code and load it into memory.

        // Step 1: Lex and parse the input file.  The lexer and parser are
        // generated by ANTLR. To see the grammar, have a look at the .g4 file.
        // If you find some of the Scriptism* classes are missing or out of
        // date, that is because those classes are generated from the .g4 file
        // from the ANTLR tool.
        ANTLRInputStream input = new ANTLRInputStream(new FileInputStream(options.getScript()));
        ScriptismLexer lexer = new ScriptismLexer(input);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        ScriptismParser parser = new ScriptismParser(tokens);
        ErrorListener errorListener = new ErrorListener();
        parser.addErrorListener(errorListener);

        // The .program() method is the root node of the grammar specified in
        // the .g4 file.
        ParseTree tree = parser.program();

        if (errorListener.isErrorFound()) {
            System.exit(1);
        }

        // Step 2: Use the generated ANTLR visitor to generate byte code.
        // Parsed computer programs are stored in a tree structure, commonly
        // called an AST. A visitor for the tree will receive callbacks at each
        // node of the tree, giving it a chance to see what information the
        // parser found at that node and take some action at that time. The
        // SimpleScript visitor will use the ASM library to generate byte code
        // that corresponds to program statements SimpleScript supports.
        final String className = "ScriptClass";
        ByteCodeGenerationVisitor visitor = new ByteCodeGenerationVisitor(className);
        visitor.visit(tree);

        if (options.getWriteClassfile()) {
            ClassLoaderUtils.writeClassToFile(className, visitor);
        }

        Class c = ClassLoaderUtils.loadClass(className, visitor.getResult());

        // Now that the new class is loaded into memory, use reflection to call
        // the main method. Pass in the arguments to this method with the
        // program name trimmed off.
        MethodUtils.invokeExactStaticMethod(c,
                "main",
                new Object[]{options.getArgs()},
                new Class<?>[]{String[].class});

    }

}
